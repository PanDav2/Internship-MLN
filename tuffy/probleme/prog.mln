// Hard Constraints

//Predicats clos

*HasMeanWord(p,q)
*PhrasesDepOne(p,q)
//h1
HasPhrase(p) => HasResource(p,x).
//h2
HasRessource(p,x) => HasPhrase(p).
//h3
HasResource(p,v18) AND HasResource(p,v19)  => v18 = v19
//h4
!HasPhrase(p) =>!HasResource(p,r).
//h5
HasRessource(x,r) => HasRelation(r,v1,v2) hasrelation(v3,r,v4).

//h6
HasRelation(r1,r2,v20) AND HasRelation(r1,r2,v21)  => v20=v21
//h7
HasRelation(r1,r2,v5) => HasResource(v6,r1) AND HasResource(v7,r2).
//h8
PhraseIndex(p1,s1,e1,) AND PhraseIndex(p2,s2,e2) AND Overlap(s1,e1,s2,e2) AND HasPhrase(p1) =>!hasPhrase(p2).
//h9
ResourceType(r,Entity) => !HasRelation(r,v8,"2_1") AND !HasRelation(r,v9,"2_2").
//h10
ResourceType(r,Entity) => !HasRelation(,r,"2_1") AND !HasRelation(r,v10,"2_2").
//h11
ResourceType(r,Class) => !HasRelation(r,v11,"2_1") AND !HasRelation(r,v12,"2_2").
//h12
ResourceType(r,Class) => !HasRelation(v13,r,"2_1") AND !HasRelation(r,v14,"2_2").
//h13
!IsTypeCompatible(r1,r2,rr) => !HasRelation(r1,r2,rr).

//SOFT CONSTRAINTS FORMULAS

PriorMatchScore(p,r,s) => HasPhrase(p)
PriorMatchScore(p,r,s) => HasResource(p)
PhrasePosTag(p,pt) AND ResourceType(r,rt)  => HasResource(p,r)
PhraseDepTag(p1,p2,dp) AND HasResource(p1,r1) AND HasResource(p2,r2)  => HasRelation(r1,r2,rr)
PhraseDepTag(p1,p2,dp) AND HasResource(p1,r1) AND HasResource(p2,r2) AND !HasMeanWord(p1,p2) => hasRelation(r4,r2,rr)
HasRelatedness(r1,r2,s) AND HasResource(v15,r1) AND HasResource(v16,r2)  => HasRelation(r1,r2,v17)
HasQueryResult(r1,r2,r3,rr1,rr2) => HasRelation(r1,r2,rr1) AND HasRelation(r2,r3,rr2)
